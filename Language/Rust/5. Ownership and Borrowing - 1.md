Rust의 메모리 관리 규칙: Rust 만의 고유한 특징
## Intro
프로그래밍 언어들은 각자 자기만의 메모리 관리 전략으로 프로그램의 메모리를 관리한다.
- GC: Java, Go, Python, JavaScript
- 프로그래머가 직접 관리: C/C++
- 컴파일 시점에서 메모리 관리 규칙을 검사: Rust
### Garbage Collector
런타임에서 사용하지 않는 데이터에 대해 GC가 메모리를 회수한다. 개발의 편의성이 올라간다.
현대 많이 사용하는 대부분의 언어는 GC를 사용하여 메모리를 관리하지만, GC는 프로그램 실행 시 성능상 오버헤드가 발생하여 불이익을 감수하여 사용하게 된다: 대부분의 경우는 괜찮지만 프로그램이 활발하게 동작하는 환경에서는 문제를 일으킬 수 있다(하드웨어 성능이 부족한 디바이스에서 동작할 경우도 포함).
### 수동 메모리 관리
개발자가 메모리 할당과 해제 작업을 지시하여 개발 속도도 느리고 난이도도 올라가지만 실행시 메모리 관리에 필요하지 않기 때문에, 즉 프로그래머가 작성한대로만 실행하기 때문에 런타임에서 이에 들어가는 메모리 관리 부담은 최소이다.
수동 조작이기 때문에 실수에 의한 버그가 다발하고 개발 속도가 느려진다. 
### Rust에서 메모리 관리
이에 반해 Rust는 독특한 메모리 관리 전략을 취하는데, 프로그래머가 메모리 관리 규칙을 준수한다면(컴파일 시점에서 검사) 컴파일러가 알아서 메모리를 회수하는 것이다: 소유권 규칙에 따라 컴파일 시점에 메모리를 할당/해제를 관리한다. 규칙에 어긋나면 컴파일되지 않으며(컴파일 오류), 이에 따라 실행 시간에 손해가 없으면서도 실수의 여지가 없다.
## Rust의 메모리 관리 규칙
> [!important] Rule 1: 블록 안에서 변수가 유효하며, 블록을 벗어나면 무효이다.

```rust
fn main() {
	{
		let s = "헬로";
		println!("s = {}", s);
	}
	println!("s = {}", s); //유효하지 않은 명령: 컴파일 불가
}
```
### Stack과 Heap
다른 언어에서 필수적이지는 않지만 Rust에서는 필수적으로 알고 있어야 함. 소유권 규칙을 숙지한다면 크게 신경쓰지 않아도 된다.
- Stack: 런타임에서 stack 메모리로 할당된 구역을 차곡차곡 쌓아가며 사용하는 메모리 공간. 함수가 호출되면 stack 영역에 쌓이고, 값이 반환되면 stack에서 해당 함수가 제거된다. 
- Heap: 할당된 공간에 메모리를 할당했다가 사용이 끝나면 메모리 할당을 해제하는 방식으로 구현된다. 자유로운 위치에 할당하며 크기도 크게 할당이 가능하고, 모자르다면 더 큰 공간을 사용하는 것도 가능하다.
#### 문자열 리터럴과 String
- 기본형 데이터는 stack 에서 쉽게 관리가 가능하다.
- _문자열 리터럴_(String Literal, 불변immutable이다)은 프로그램 실행시 고정으로 확보되므로 stack, heap모두 아니다(동적 메모리로 관리를 하지 않으니까): Rust에서 `&str`로 표시
- 사용자가 입력하는 _String_ 은 미리 크기를 알 수 없으므로, 즉 컴파일 시점에 **크기를 알 수 없으므로 heap 메모리에 저장해야** 한다.
```rust
fn main() {
	let s = "헬로"; // 문자열 리터럴, 마우스를 올려보면 `&str`로 출력되는 것을 확인할 수 있다.
}
```
String literal

```rust
fn main() {
	let s: String = String::from("헬로");
}
```
1. from은 리터럴로 입력받은 "헬로"를 String 타입으로 변환한다(런타임에서): 필요한 만큼의 메모리를 힙 영역에 할당하고, 그 위치를 가르키는 포인터와 문자열의 길이/용량을 저장한 구조체(String)를 반환한다.
2. Rust에서 String 타입은 힙에 있는 데이터를 가리키는 포인터, 길이, 용량을 포함한 구조체이고, 스택 영역에 저장된다.
3. s는 스택에 저장된 String 구조체를 가르키는 변수로, heap에 저장된 문자열을 가르키는 게 아니라, 그것을 가르키는 포인터를 포함한 구조체를 가지고 있는 것이다.
Heap에 저장하였으므로 이 값은 mutable하다. 이렇게:
```rust
fn main() {
	let s: String = String::from("헬로");
	s.push_str(", 월드!");
	println!("s = {}", s);
}
```
Rust는 이렇게 동적으로 할당된 메모리 공간 해제를 위해 소유권 규칙을 적용하여 관리한다.
### 소유권 규칙
앞에서 살펴본 메모리 할당에 대한 내용을 바탕으로, 다음의 소유권 규칙을 자세히 살펴 볼 수 있다.
> [!important] Rule 2. 소유권 규칙
> 1. 모든 값은 소유자(owner)가 있다.
> 2. 한 시점에 하나의 소유자만 있을 수 있다.
> 3. 소유자의 범위가 끝나면 , 값도 제거된다.

위 규칙으로부터, 다음과 같은 경우가 발생한다.
- 소유권을 넘기게 되면 원래 소유권은 박탈된다.
- 소유권이 박탈당한 소유자가 범위를 벗어나면, 해당 소유자는 소멸된다.
- 소유권을 양도받은 소유자가 범위를 벗어나면, 해당 소유자와 그 소유자에 속한 값 모두 소멸된다.

Rust가 이 소멸 과정을 진행해준다. 예시를 통해 자세히 살펴보자:

```rust
fn main() {
	let x= 3;
	let y = x;
	println!("x = {x}, y = {y}");
}
```
y의 경우, x의 3이라는 값이 y로 복사된다. 이를 String에서 다시 진행해보면,
```rust
fn main() {
	{
		let s1= String::from("헬로");
		// "헬로"의 위치: Heap, "헬로"의 소유자: s1(Stack에 위치) 
		let s2 = s1; // 소유권이 s1에서 s2로 넘어간다.
		println!("s2 = {}", s2);
		println!("s1 = {}", s1); // 사용할 수 없다!!
	}
}
```
- 소유권 이전Ownership Transfer: s1은 더이상 유효하지 않다; **메모리 주소(포인터)** 와 관련된 값만 이동한다.
- 소유권이 이전된 상태에서 s1은 소유권을 잃었기 때문에, 유효하지 않은 참조를 방지하기 위해 Rust는 컴파일 타임에 이를 잡아낸다.
- scope가 종료될 때, Rust는 s2의 소유권이 종료된 것을 감지, 힙에 할당된 메모리를 해제한다.
- s1, s2의 경우 stack에서의 cleanup이므로, 메모리 해제 작업에 대한 언급이 필요없다: stack 프레임이 사라지므로 해당 스코프 내의 stack 자료들은 같이 사라진다.

한글 utf-8의 경우, 한 글자에 3 바이트 씩 차지하므로, 다음과 같다(이미지 중비 중):

Rust는 프로그래머가 직접 지정하지 않는한, 데이터를 복사하지 않고 공유한다. 따라서 변수를 다른 변수에 할당할 경우, 두 참조 변수가 하나의 데이터를 공유하지만, 소유권 문제 때문에 이전의 소유자는 소유권이 박탈된다. 데이터를 복사하려면:
```rust
fn main() {
	let s1 = String::from("헬로");
	println!("s1 = {}", s1);
	let s2 = s1.clone();
	println!("s1 = {}", s1);
	println!("s2 = {}", s2);
}
```

### 기본 데이터 타입: Stack에 저장
1. 정수 타입: u32, i64, ...
2. 부울 타입: bool(true/false)
3. 문자 타입: char
4. 튜플
	- (i32, bool) → Stack에 저장
	- (i32, String) → Stack에 저장되지 않음
### 함수 호출 시 소유권 이동
```rust
fn main() {
	let s = String::from("헬로");
	string_length(s); // 전달, 함수에 변수의 소유권이 전달된다.
	println(s); // 불가능!
	
	let x = 3; // 데이터 크기를 아는 기본 데이터는 소유권 관리를 하지 않는다.
	double(x);
	println!(x); // 가능!
}

fn string_length(s: String) {
	println!("문자열 s의 길이는: {}", s.len());
}

fn double(x: i32) {
	println!("x는: {}", x);
}
```
UTF-8에서 한글 한 글자는 3byte이므로 3 X 2 = 6 이 출력된다.
반환값이 있는 경우, 
```rust
fn main() {
	let s1 = String::from("헬로");
	let s2 = string_length(s1); // 전달, 함수에 변수의 소유권이 전달된다.
	println!("s = {}", s2); // 원래 s1의 소유권이 main 함수로 돌아옴
}
fn string_length(s: String) {
	println!("문자열 s의 길이는: {}", s.len());
	s
}
```

변수에 대한 특정 작업만 진행하는 경우, 변수의 소유권이 함수로 넘기지 않는 간단한 방법이 있다: 튜플로 받기
```rust
fn main() {
	let s = String::from("헬로");
	let (len, s) = string_length(s);
	println!("문자열 s = {}의 길이는 = {}", s, len);
}

fn string_length(s: String) -> usize {
	println!("s = {}", s);
	(s.len(), s)
}
```
