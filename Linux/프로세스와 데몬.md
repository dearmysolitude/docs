## 프로세스
운영체제에 의해 메모리에 적재되어 실행 중인 프로그램의 인스턴스. 프로세스마다 고유의 PID가 부여된다. Foreground/background 프로세스로 나뉘며 모든 실행중인 프로그램은 프로세스이다. 자식 프로세스를 만들 수 있다.
### `fork()`와 `exec()`
`fork()`와 `exec()`는 모두 새 프로세스를 만드는 **시스템 호출**이지만 차이점이 있다.
#### fork()
- 현재 프로세스의 복사본을 생성한다. 즉, 부모 프로세스와 동일한 코드, 데이터, 힙, 스택을 가지고 있는 프로세스가 발생한다.
- 원본은 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스로 실행된다.
- 서로 별도의 메모리 공간을 가지므로 변수 값을 변경해도 서로 영향을 주지 않는다.
#### exec()
- 현재 프로세스의 코드, 데이터, 힙, 스택 영역을 새로운 프로그램으로 대체한다.
- PID는 동일하지만 프로그램이 완전히 바뀌게 된다.
- 자식 프로세스를 새로운 프로그램으로 대체하려면 `fork()` 다음에 `exec()`를 호출한다.
### foreground/background
리눅스에서 프로그램을 실행하면 해당 프로세스는 유니크한 ID(PID)로 생성되며 foreground에서 실행된다. Foreground 프로세스는 사용자와 스크린 및 키보드를 통해 통신할 수 있다. Background 프로세스는 터미널과 연결되지 않으므로 사용자와 통신할 수 없다. 
출처: [foreground, background- 이지IT](https://easyitwanner.tistory.com/76)
- 백그라운드 작업을 실행하기 위해서는 프로그램 이름 뒤에 `[작업번호]&`를 붙이면 된다. 백그라운드 작업을 호출 시는 `$[작업번호]`로 명령을 내릴 수 있다(실행한 백그라운드 작업은 `jobs`로 확인 가능). 
### 멀티테스킹: 여러 개의 프로세스를 한 번에
CPU는 한 번에 한 가지 작업 밖에 할 수 없기 때문에 운영체제는 여러 프로그램을 한 번에 작동하기 위해서는 한 프로세스를 짧은 시간 동안 연산 하고 다른 프로세스를 처리하는 타임 쉐어링(Time sharing) 기법을 통해 여러 프로세스를 구동할 수 있게 된다.
- 운영체제는 어떤 프로세스에 CPU를 할당할 지 결정하는 스케줄링 정책을 가지고 있으며, 이를 **CPU 스케줄링**이라고 한다.
- **Time slice**는 한 프로세스가 CPU를 사용할 수 있는 최대 시간을 의미한다.
- 이러한 스케줄링에 따라 **프로세스는 상태**를 가지게 된다.
	<figure style="width: 85%" class="align-center">
  <img src="https://onedrive.live.com/embed?resid=C4F97B3B64AE3E7A%217110&authkey=%21AHHjb7j11mxQK3c&width=652&height=254" alt="">
  <figcaption>프로세스의 상태</figcaption>
</figure>
- 프로세스의 상태가 전환됨에 따라 **문맥 교환(Context switching)** 작업이 발생한다. 프로세스가 전환됨에 따라 프로세스의 레지스터 값, 메모리 상태 등을 저장하고 복원하는 작업이다.
[참고: 프로세스 스케쥴링 - 1FeS님 블로그](https://wch18735.github.io/os/Process_Scheduling%281%29/)
## 데몬
주기적인 서비스 요청을 처리하기위해 계속 실행되는 특별한 프로그램이다. 백그라운드에서 실행되는 프로세스의 한 종류이며 데몬은 systemd 의 자식으로 생성되기 때문에 다른 프로세스와 구별된다.
- 사용자가 직접 제어하지 않고 특정 작업을 지속적으로 수행
- 주기적으로 시스템 데이터를 갱신하거나 특정 이벤트 발생 시 작동
데몬 프로세스는 사용자의 제어 없이 프로세스를 처리하기 때문에 대부분 systemd의 자식프로세스로 실행된다. 현재 linux 배포판에서 init 시스템 및 서비스 관리자 역할을 하는 systemd는 부팅시 시작되면서 각종 데몬과 자식 프로세스를 실행하고 관리한다.
### `nohup`
- 터미널이 종료되어도 프로세스가 계속 실행되도록하는 유닉스 명령어이다.
- 이 명령어로 실행한 프로세스는 systemd 프로세스의 자식 프로세스로 실행되며, 시스템의 가장 상위 프로세스가 된다.
- 데몬으로 실행하면 표준 출력으로 출력하는 대신 nohup.out파일에 출력한다.
- `ps -ef`: `nohup`으로 실행한 프로세스 확인할 수 있음(`e`: 모든 프로세스 `f`: 모든 정보 표시)
- **`watch -n 1 'cat nohup.out'`: 1초마다 nohup.out파일에 쌓이는 것들을 추적할 때 사용.**
## 프로세스 관련 명령어
### `ps`: 프로세스 살펴보는 명령어
이 명령어를 통해 프로세스의 상태를 확인할 수 있으며, 표시되는 프로세스 상태는 다음과 같다.
	R: 실행 대기
	S: 잠든 상태
	D; 입출력을 기다리는 인터럽트가 불가한 상태
	T: 멈춰있거나 흔적이 남아있는 상
	Z: zombie상태
### `&`(앰퍼센드)
백그라운드 실행
### `fg` / `bg`
백그라운드/포그라운드 프로세스 변경\