## 계층형 질의(Hierachical Query)
- 계층형 데이터를 조회하기 위해 사용
- Oracle에서 지원
### 계층형 데이터(Hierarchial Database Modeling)
- 동일 테이블에 계층적으로 상위와 하위 데이터가 포함된 데이터
- 테이블에 계층형 데이터가 존재하는 경우 데이터를 조회하기 위해서 계층형 질의를 사용한다.
- 엔티티를 순환관계 데이터 모델로 설계할 때 발생
- 트리 구조를 사용한다. 각 노드는 데이터 항목을 나타내며, 부모-자식 관계를 통해 연결된다.
참고: [[10. DB 구조와 성능#^baee63|슈퍼타입/서브타입 모델링]], 슈퍼타입과 서브타입은 generialization과 specialization을 통하여 데이터 모델링하여 비즈니스 모델을 알기 쉽도록 표현하는 것을 가능하게 해 준다.
#### 예시
##### 온라인 상점 데이터베이스
- 테이블:
    - 상품: 상품 ID, 상품명, 가격, 수량, 카테고리
    - 주문: 주문 ID, 고객 ID, 주문 날짜, 주소, 주문 상세
    - 고객: 고객 ID, 이름, 이메일, 전화번호
- 레코드: 
    - 상품:
        - (1, "티셔츠", 20000, 100, "남성 의류")
        - (2, "핸드폰", 100000, 50, "전자제품")
    - 주문:
        - (1, 100, "2023-11-14", "서울", "(상품 ID, 수량): (1, 2), (2, 1)")
    - 고객:
        - (100, "홍길동", "hong@email.com", "010-1234-5678")
##### 관계
- 상품: 상품 ID는 주문 상세 테이블의 상품 ID와 연결됩니다.
- 주문: 주문 ID는 고객 테이블의 고객 ID와 연결됩니다.
### `START WITH`
시작 노드 지정
### `CONNECT BY`
- 트리 구조를 정의한다.
- 트리 형태의 구조로 쿼리를 수행한다: 루트 노드부터 하위 노드의 쿼리를 실행한다.
- 예: 상사 이름과 사람 이름을 조인하여 상사 밑에 추가하기
#### `CONNECT BY PRIOR`
조인 조건 설정: 이전 레벨의 값을 참조한다.
- `LEVEL`: 검색 항목의 깊이, 최상위 계층의 레벨은 1
- `CONNECT_BY_ROOT`: 최상위 계층 값 표시
- `CONNECT_BY_ISLEAF`: 최하위 계층 값 표시
- `SYS_CONNECT_BY_PATH`: 계층 구조의 전개 경로 표시
#### `CONNECT BY`절의 루프 알고리즘 키워드
- `NOCYCLE`: 순환 구조의 발생 지점까지만 전개
- `CONNECT_BY_ISCYCLE`: 순환 구조 발생 시점 표시(부모 노드와 자식 노드가 같을 때 1아니면 0 출력)
### `LPAD`
- 계층형 조회 결과를 명확히 하기 위해 사용
- `LEVEL`(현재 레벨을 나타낸다.) 값을 이용하여 결과 데이터 정렬한다.
### 예시
```SQL
CREATE TABLE 부서 (
  부서_코드 CHAR(4) PRIMARY KEY,
  부서_명 VARCHAR(20),
  상위_부서_코드 CHAR(4)
);

INSERT INTO 부서 VALUES ('A001', '총무부', NULL);
INSERT INTO 부서 VALUES ('A002', '인사부', 'A001');
INSERT INTO 부서 VALUES ('A003', '영업부', 'A001');
INSERT INTO 부서 VALUES ('A004', '마케팅부', 'A003');
INSERT INTO 부서 VALUES ('A005', '개발부', 'A001');
```
#### 모든 부서와 상위 부서 이름을 조회
```SQL
SELECT 부서_코드, 부서_명, 상위_부서_코드,
  CASE WHEN 상위_부서_코드 IS NULL THEN '최상위 부서'
       ELSE (SELECT 부서_명 FROM 부서 WHERE 부서_코드 = 상위_부서_코드)
  END AS 상위_부서_명
FROM 부서
CONNECT BY PRIOR 부서_코드 = 상위_부서_코드 -- 트리 구조를 정의
START WITH 부서_코드 = 'A001';
```
##### 결과
- `END AS`는 CASE WHEN 표현식의 결과를 별칭으로 지정하는 데 사용된다. 즉, CASE WHEN 표현식의 결과를 원하는 이름으로 바꾸는 것이다.
- `CONNECT BY PRIOR`: 부서 테이블 구조를 정의한다. 현재 레벨의 상위 부서 코드는 상위 레벨의 부서 코드를 참조한다.
- `START WITH`: 트리 구조의 시작 노드를 지정한다.
```
부서_코드 | 부서_명 | 상위_부서_코드 | 상위_부서_명
------- | -------- | -------- | --------
A001 | 총무부 | NULL | 최상위 부서
A002 | 인사부 | A001 | 총무부
A003 | 영업부 | A001 | 총무부
A004 | 마케팅부 | A003 | 영업부
A005 | 개발부 | A001 | 총무부
```
#### 특정 레벨의 부서만 조회
```SQL
SELECT 부서_코드, 부서_명
FROM 부서
CONNECT BY PRIOR 부서_코드 = 상위_부서_코드
START WITH 부서_코드 = 'A001'
AND LEVEL <= 2;
```
##### 결과
```
부서_코드 | 부서_명
------- | --------
A001 | 총무부
A002 | 인사부
A003 | 영업부
```
#### 부서별 직원 수를 조회
```SQL
-- 직원 테이블
CREATE TABLE 직원 (
  직원_코드 NUMBER PRIMARY KEY,
  이름 VARCHAR(20),
  부서_코드 CHAR(4)
);

INSERT INTO 직원 VALUES (100, '김철수', 'A001');
INSERT INTO 직원 VALUES (101, '박지영', 'A002');
INSERT INTO 직원 VALUES (102, '이영희', 'A003');
INSERT INTO 직원 VALUES (103, '최민수', 'A004');
INSERT INTO 직원 VALUES (104, '김지영', 'A005');
```
```SQL
SELECT 부서_명, COUNT(*) AS 직원수
FROM 부서 a
INNER JOIN 부서 b ON a.부서_코드 = b.상위_부서_코드
GROUP BY a.부서_명
CONNECT BY PRIOR 부서_코드 = 상위_부서_코드
START WITH 부서_코드 = 'A001';
```
##### 결과
- 아래 두 줄은 계층형 구조를 정의하고 시작 계층을 설정한다. 하지만 `CONNECT BY`는 직원 수를 직접 계산하지는 않는다.
- `SELECT` 문에서는 부서 테이블을 a, b로 별칭을 정하여 두 테이블에서 부서 코드와 상위 부서 코드가 일치하는 `INNER JOIN`을 실행한다. `INNER JOIN`은 각 부서와 하위 부서의 직원들을 하나의 테이블로 합쳐 직원 수를 계산한다.
```
부서_명 | 직원수
------- | --------
총무부 | 2
인사부 | 1
영업부 | 1
마케팅부 | 1
개발부 | 1
```
## SQL Server의 계층형 질의
`CTE`(Common Table Expression)으로 재귀 호출
## 셀프 조인
하나의 테이블에서 두 개 이상의 가상 테이블처럼 간주하여 조인하는 방식이다. 테이블 자기 자신을 조인하는 것처럼 보이기 때문에 셀프 조인이라고 불린다.
### 용도
- 데이터 비교
- 계층 구조 만들기
- 중복 데이터 찾기
- 변화 추적
### 예시
1. 다음 직원 테이블을 예시로 살펴보자
```
| 이름  | 부서  | 직급  |
| --- | --- | --- |
| 김철수 | 개발  | 주임  |
| 박지영 | 영업  | 사원  |
| 이영희 | 마케팅 | 대리  |
```
2. 셀프 조인으로 부서별 직원 수 구하기
```MySQL
SELECT b.부서, COUNT(*) AS 직원수
FROM 직원 a
INNER JOIN 직원 b ON a.부서 = b.부서
GROUP BY b.부서;
```
```
-- 결과
| 부서  | 직원수 |
| --- | --- |
| 개발  | 1   |
| 영업  | 1   |
| 마케팅 | 1   |
```
3. 셀프 조인으로 관리자와 직원을 구분하기
```MySQL
SELECT a.이름, a.직급,
CASE WHEN b.이름 IS NULL THEN '직원' ELSE '관리자' END AS 관계
FROM 직원 a
LEFT JOIN 직원 b ON a.이름 = b.상사;
```
```
-- 결과
| 이름  | 직급  | 관계  |
| --- | --- | --- |
| 김철수 | 주임  | 직원  |
| 박지영 | 사원  | 직원  |
| 이영희 | 대리  | 관리자 |
```
### 장점
- 데이터 분석: 다양한 방식으로 데이터를 분석할 수 있다.
- 유연성: 다양한 조건을 사용하여 쿼리를 작성할 수 있다.
- 효율성: 테이블을 여러 번 스캔할 필요 없이 원하는 결과를 얻을 수 있다.
### 단점
- 복잡성: 쿼리가 복잡해질 수 있다.
- 성능: 데이터 규모가 커지면 성능 저하가 발생할 수 있다.
### 주의 사항
- 한 테이블 내에서 두 칼럼이 연관 관계가 있는 경우, 앨리어스가 필수이다.
## MySQL
`HIERARCHY()`, `RECURSIVE()` 쿼리를 지원한다.