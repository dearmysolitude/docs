## 발생 문제들
- 컨트롤러의 경로 설정.
	- 주소 mapping이 static 페이지와 충돌하지 않도록
	- 리디렉팅 하는 경우에 대해 상대경로와 절대경로의 활용: 인터셉터로 특정 페이지로 이동하는 경우도 더 골치아프게 함
	- 프로젝트 path 설정
참고: [여러 controller 전략](https://kimcoder.tistory.com/481), [Controller 작성 전략(JPA 미사용시)](https://coding-start.tistory.com/56)
- JPA
	- H2를 활용하는 경우 네이밍 주의. 매핑이 제대로 되지 않는 경우가 많다: snake case
	- 1+N 해결을 위한 fetch join
	- 순환 참조를 막기 위한 전략: annotation보다는 DTO라는데 이건 찾아봐야 할 듯
	- JPA QueryFactory: 
- 테스트 코드로 테스트해가며 작성하기: 시간은 좀 걸리겠지만 모든 계층에 대해 확인이 필요함. 특히 컨트롤러 단까지 테스트가 좀 필요할 듯
- 배포
	- 서버의 로그는 항상 확인하자: tomcat의 경우 cataline.out
	- Gradle의 dependency 중 providedRuntime 으로 가져온 tomcat의 경우, 외부 tomcat으로 실행 시 스프링 boot 내부 tomcat을 실행하지 않도록 해서 충돌이 나지 않도록 해준다.
- 페이지네이션 기능에 대해서는 AOP 를 적용해서 어떤 컨텐츠에 대해서도 페이지네이션 로직을 적용할 수 있을 것
- 객체 전달 전략: 기본적으로 DTO를 생성.
- 메서드 리팩터링이 조금 필요하긴 한데: how? 
- JWT 다시 + 이번에는 OAuth2까지
## Spring Security
기초: [Spring Security란? - 망나니 개발자](https://mangkyu.tistory.com/76)

## 예약 시스템
### ERD 설계
#### 호텔 리뷰에서 호텔 룸 정보는 db단에서 어떻게 구현하지?
대형 서비스에서 호텔 리뷰 시스템을 구현할 때 방 ID를 외래 키로 직접 참조하는 것은 실제로 몇 가지 문제를 야기할 수 있습니다. 일반적으로 다음과 같은 접근 방식을 사용합니다:
1. 호텔 단위의 리뷰:
   대부분의 서비스는 개별 방이 아닌 호텔 전체에 대한 리뷰를 받습니다. 이 경우 리뷰 테이블은 호텔 ID만 외래 키로 참조합니다.
2. 리뷰 메타데이터:
   방 정보를 직접 참조하는 대신, 리뷰 시 선택한 방 타입이나 특성을 메타데이터로 저장합니다. 예를 들어:
   ```
   review_id | hotel_id | room_type | review_text | ...
   ```
3. 중간 테이블 사용:
   리뷰와 방 사이에 중간 테이블을 두어 관계를 유연하게 관리합니다:
   ```
   review_id | hotel_id | review_text | ...
   review_room | review_id | room_id
   ```
4. 비정규화:
   방 정보의 스냅샷을 리뷰 테이블에 직접 저장합니다. 이는 데이터 중복을 야기하지만 조회 성능을 향상시킬 수 있습니다.
5. NoSQL 활용:
   리뷰 데이터를 문서 기반 NoSQL 데이터베이스에 저장하여 유연한 스키마를 활용합니다.
6. 이벤트 소싱:
   리뷰 작성 시점의 방 정보를 이벤트로 기록하고, 필요시 이를 재구성합니다.
이러한 접근 방식들은 다음과 같은 이점을 제공합니다:
- 유연성: 방 구조 변경에 덜 민감합니다.
- 확장성: 대량의 리뷰 데이터 처리에 용이합니다.
- 성능: 복잡한 조인 없이 리뷰 데이터를 빠르게 조회할 수 있습니다.
### JPA의 ENUM
> [JPA에서 안전하게 enum 쓰기](https://medium.com/frientrip/spring-jpa%EC%9D%98-enum-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EC%93%B0%EC%9E%90-f60525a882b0)
> [JPA Entity Enum Converter를 좀 더 유연하게 쓰는 법](https://medium.com/@rnrghks09/jpa-entity-enum-converter%EB%A5%BC-%EC%A2%80-%EB%8D%94-%EC%9C%A0%EC%97%B0%ED%95%98%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-32e952fba28e)

JPA에서 enum을 사용하기 위해서@Enumerated를 사용할 수 있으나, 공식 문서에는:
> If the enumerated type is not specified or the Enumerated annotation is not used, the EnumType value is assumed to be ORDINAL.
즉, `Enumerated` 어노테이션을 사용하지 않았거나, `EnumType`을 지정해주지 않았을 때 Enum Type에 enum 값 순서를 db에 저장한다.
이 경우, Enum 클래스에 수정이 가해지는 경우, DB와의 정합성이 깨지게 된다.