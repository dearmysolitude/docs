게시물을 다루는 페이지에서, 개시글을 다루는 데이터에는 게시글 자체의 id 외에도, 댓글 기능을 구현하기 위한 메타데이터를 구성하여 댓 게시글 기능을 구현하였다. 

```SQL
CREATE TABLE board(
	id int NOT NULL PRIMARY KEY AUTO_INCREMENT,
	title varchar(70),
	date TIMESTAMP DEFAULT CURRENT_TIMESTAMP ,
	content text
) DEFAULT CHARSET=UTF8;
```
초기 게시판 DB 정의

```sql
-- 댓 게시글 기능 추가: 테이블 수정 후 기존 샘플 데이터 업데이트
ALTER TABLE board ADD rootid int;
ALTER TABLE board ADD relevel int;
ALTER TABLE board ADD recnt int;
ALTER TABLE board ADD viewcnt int DEFAULT 0;
```

여기에서 rootId는 원 게시글, relevel은 댓글 수준, recnt는 rootid내에서 댓글의 순서, viewcnt는 조회수를 속성이다.
이 경우, 댓글을 달 때마다 새로운 recnt를 부여하고 삭제시 다시 업데이트 하는 것이 주요 로직이 된다. 따라서 recnt를 순서대로 정렬하여 조회하게 되면 1 ~ (댓글의 수) 가 오름차순으로 조회되는 것이다.
주어진 삽입을 원하는 recnt를 구하기 위해, 
1. 현재 댓글을 달 recnt보다는 큰 것들 중에서,
2. 내 reLevel보다 크거나 같은 recnt 중,
3. 최소의 recnt가 새 댓글이 자리할 recnt이다.
4. 만약 조회를 실패한 경우: 가장 마지막에 댓글을 달면 된다.
이 알고리즘에 대한 코드는 블로그에 업로드 한다.
## 코멘트를 불러오는 DAO
### 원본
```java
`List<CommentItem> list = new ArrayList<>();
try { return executeDatabaseOperation(conn -> {
	String query = String.format("SELECT id, date, content, relevel, recnt FROM comment WHERE rootid=? ORDER BY recnt asc;");
	try (PreparedStatement stmt = conn.prepareStatement(query)) 
		{ 
			stmt.setInt(1, rootId); System.out.println(query); 
			ResultSet rset = stmt.executeQuery(query);
			while(rset.next()) { 
				CommentItem newItem = new CommentItem.Builder()
				 .id(rset.getInt("id")) 
				 .content(rset.getString("content")) 
				 .date(rset.getDate("date")) 
				 .reLevel(rset.getInt("relevel")) 
				 .reCnt(rset.getInt("recnt"))
				 .build();
				 list.add(newItem);
				}
			return list;
			} 
		}); 
	} catch (SQLException e) {
	System.out.println(e.getMessage()); 
	return list;
}
```

### 개선
```java
public List<CommentItem> selectComments(int rootId) {
	List<CommentItem> list = new ArrayList<>();
	try {
	    return executeDatabaseOperation(conn -> {
	        String query = "SELECT id, date, content, relevel, recnt FROM comment WHERE rootid = ? ORDER BY recnt ASC";
	        try (PreparedStatement stmt = conn.prepareStatement(query)) {
	            stmt.setInt(1, rootId);
	            try (ResultSet rset = stmt.executeQuery()) {
	                while (rset.next()) {
	                    CommentItem newItem = new CommentItem.Builder()
	                            .id(rset.getInt("id"))
	                            .content(rset.getString("content"))
	                            .date(rset.getDate("date"))
	                            .reLevel(rset.getInt("relevel"))
	                            .reCnt(rset.getInt("recnt"))
	                            .build();
	                    list.add(newItem);
	                }
	            }
	            return list;
	        }
	    });
	} catch (SQLException e) {
	    System.err.println("데이터베이스 쿼리 실행 중 오류 발생: " + e.getMessage());
	    e.printStackTrace();
	    return list; // 예외 발생 시 빈 리스트 반환
	}
}
```
### 설명
- SQL Injection 취약점 해결:
    - 원래 코드에서는 `stmt.executeQuery(query)`를 사용하고 있었는데, 이는 이미 준비된 명령문에 쿼리를 다시 전달하는 것입니다. 대신 `stmt.executeQuery()`를 사용하여 이미 설정된 매개변수로 쿼리를 실행해야 합니다.
- 리소스 관리 개선:
    - `ResultSet`도 `try-with-resources` 구문으로 감싸 자동으로 닫히도록 했습니다.
- 쿼리 문자열 개선:
    - `String.format()`을 사용할 필요가 없어 제거했습니다. 준비된 명령문을 사용하므로 쿼리 문자열에 직접 값을 삽입할 필요가 없습니다.
- 예외 처리 개선:
    - 예외 메시지를 `System.err`로 출력하도록 변경했습니다.
    - 스택 트레이스를 출력하여 디버깅에 도움이 되도록 했습니다.
- 불필요한 출력 제거:
    - 디버깅용으로 보이는 `System.out.println(query);`를 제거했습니다.

