---
sticker:
---
[Quiz | 퀵소트 정렬시 데이터의 변화](https://www.notion.so/Quiz-a5ad224f850544af898eaee35db7cc26?pvs=21)
## Sort정렬
- 키를 항목값의 대소관계에 따라 데이터 집합을 일정 순서로 바꾸어 늘어놓는 작업
- 오름차순/내림차순이 있음
- 정렬 알고리즘에는 총 8가지가 있으며, 안정적인Stable 알고리즘과 그렇지 않은 알고리즘이 있다. **안정적인 알고리즘은 값이 같은 원소의 순서가 정렬한 후에도 유지되는 것을 말한다.**
- 하나의 배열에서 작업할 수 있는 경우 내부 정렬을 사용하고, 그렇지 않은경우 외부 정렬을 사용한다. 외부 정렬은 많은 데이터를 하나의 배열에 저장할 수 없어 사용하는 경우로, 알고리즘도 복잡하고 작업용 파일이 필요하다.
- 교환, 선택, 삽입을 기반으로 작동한다.
## 정렬의 종류
### 버블 정렬Bubble
- 두 원소를 비교, 교환을 반복한다. 시간복잡도: O(n2)
### 단순 선택Straight Selection
O(n2)
### 단순 삽입Straight insertion
O(n2) /이진 삽입: 이진 검색법을 사용하여 삽입 정렬 → 비용 줄일 수 있음. 단순 삽입-장점: 정렬을 마쳤거나 끝나가는 상태에서는 속도가 아주 빠름. 단점: 삽입할 위치가 멀리 떨어져 있으면 이동횟수가 많아진다.
### 셸 정렬Shell
정렬할 배열의 원소를 그룹으로 나누어 그룹별로 정렬 수행, 그 후 그룹을 합친다.
### **퀵 정렬Quick**
가장 빠른 정렬, 피벗 값을 무엇을 선택하느냐에 따라 성능을 좌우한다.
- Quick Sort는 대표적인 분할 정복(Divide and Conquer) 알고리즘으로, 평균적으로 매우 빠른 실행 속도를 가지고 있습니다. Quick Sort는 pivot을 선택하고 pivot을 기준으로 배열을 두 개로 분할하는 방식으로 동작합니다….

    먼저, Quick Sort 알고리즘에서 pivot을 선택합니다. 일반적으로는 배열의 가운데 원소를 pivot으로 선택합니다. pivot을 선택한 후에는 배열을 pivot보다 작은 원소들과 큰 원소들을 각각 pivot의 왼쪽과 오른쪽에 위치하도록 분할합니다. 이때, pivot 원소는 정렬된 위치에 위치하게 됩니다.

    이 분할을 수행하기 위해서는 두 개의 인덱스를 사용합니다. 첫 번째 인덱스는 배열의 첫 번째 원소를 가리키고, 두 번째 인덱스는 배열의 마지막 원소를 가리킵니다. 이후, 첫 번째 인덱스를 오른쪽으로 이동하면서 pivot보다 큰 원소를 찾습니다. 두 번째 인덱스를 왼쪽으로 이동하면서 pivot보다 작은 원소를 찾습니다. 이 두 원소를 서로 교환합니다. 이 과정을 반복하다가 두 인덱스가 서로 만나면 분할이 완료됩니다.

    이제 분할된 두 개의 하위 배열을 각각 Quick Sort 알고리즘을 이용하여 재귀적으로 정렬합니다. 이를 반복하여 하위 배열의 크기가 1 이하가 될 때까지 분할하고 정렬하면, 배열 전체가 정렬됩니다.

    Quick Sort의 평균 시간복잡도는 O(n log n)이며, 최악의 경우 O(n^2)입니다. 최악의 경우는 pivot이 항상 배열의 최솟값이나 최댓값으로 선택되는 경우입니다. 이 경우에는 분할이 제대로 이루어지지 않아, Quick Sort의 효율성이 크게 떨어집니다. 따라서 pivot의 선택은 알고리즘의 성능에 큰 영향을 미치기 때문에, pivot을 랜덤하게 선택하거나 배열에서 중간값을 선택하는 방식 등의 pivot 선택 방법을 사용하는 것이 일반적입니다.
```python

def quick_sort(array, start, end):

    if start >= end: return

    pivot = start

    left, right = start +1, end #포인팅

  

    while left <= right:

        #피벗보다 작은 데이터를 찾을 때까지 반복

        while left <= end and array[left] <= array[pivot]:

            left += 1

        # 피벗보다 큰 데이터를 찾을 때까지 반복

        while right > start and array[right] >= array[pivot]:

            right -= 1

        if left > right:

            array[right], array[pivot] = array[pivot], array[right]

        else: #엇갈리지 않은 경우

            array[right], array[left] = array[left], array[right]

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행

    quick_sort(array, start, right-1)

    quick_sort(array, right +1 , end)

```

### 병합 정렬Merge

### **힙 정렬Heap**


힙의 특성을 이용하여 정렬하는 알고리즘. 힙은 “부모의 값이 자식의 값보다 항상 크다”는 조건을 만족하는 완전 이진 트리이다. 부모가 항상 크거나() 항상 작거나, 대소관계가 일정하면 된다. 부모관계는 일정하지만 형제 사이의 대소 관계는 일정하지 않다. 따라서 힙을 부분 순서 트리partial ordered tree라고도 부른다.

  

힙을 배열에 저장하게 되면 다음의 관계로 부모/자식 노드를 찾을 수 있다. 원소 a[i]에서,

부모 노드: a[ (i - 1) // 2 ]

왼쪽 자식 노드: a[ i * 2 + 1 ]

오른쪽 자식 노드: a[ i * 2 + 2 ]

“힙에서 최댓값은 루트에 위치한다”는 특징을 이용하여 정렬을 진행한다: 힙에서 최댓값인 루트를 꺼낸다 / 루트 이외의 부분을 힙으로 만든다.

- 2주차 퀴즈를 보면 코드와 자료의 변화를 확인할 수 있을 것.

### **도수정렬Counting**
- Counting Sort는 정수들의 배열을 정렬하는 알고리즘 중 하나입니다. 배열에 있는 각 항목의 숫자들을 세서 각 항목이 몇 번 등장했는지를 센 다음, 그것을 기반으로 배열을 정렬합니다….

    예를 들어, 정렬하려는 배열이 [3, 1, 4, 1, 5, 9, 2, 6, 5, 3]이라고 가정해봅시다. 이 배열에서 가장 작은 숫자는 1, 가장 큰 숫자는 9입니다. 따라서 카운트 배열을 9 크기로 만들고, 배열의 각 항목을 순회하며 각 숫자가 몇 번 등장하는지 카운트합니다.

    그러면 다음과 같은 카운트 배열이 만들어집니다: [0, 2, 1, 2, 1, 2, 1, 0, 1]. 이 배열에서 인덱스 i의 값은 숫자 i가 원래 배열에서 몇 번 등장했는지를 나타냅니다.

    이제 정렬된 배열을 만들기 위해, 카운트 배열을 순회하면서 각 숫자가 나올 위치를 계산합니다. 이를 위해, 카운트 배열의 인덱스 i의 값을 i 이전 값들의 합으로 변경합니다. 따라서, 카운트 배열을 누적합으로 변환하면 [0, 2, 3, 5, 6, 8, 9, 9, 10]이 됩니다.

    이제, 원래 배열을 뒤에서부터 순회하면서, 각 항목을 카운트 배열을 참조하여 정렬된 위치에 삽입합니다. 예를 들어, 배열의 마지막 항목인 3을 본다면, 카운트 배열에서 3이 나올 위치는 5번째입니다. 따라서, 정렬된 배열의 5번째에 3을 삽입합니다. 이 과정을 모든 항목에 대해 반복하면, [1, 1, 2, 3, 3, 4, 5, 5, 6, 9]와 같은 정렬된 배열이 만들어집니다.

    Counting Sort의 시간복잡도는 O(n + k) 입니다. n은 정렬하려는 배열의 크기이고, k는 정수의 범위입니다. 따라서, k가 n보다 작은 경우, Counting Sort는 매우 빠른 속도로 정렬을 수행할 수 있습니다.

**백준** [#2750 수 정렬하기](https://www.acmicpc.net/problem/2750) [#2751 수 정렬하기2](https://www.acmicpc.net/problem/2751) [#10989 수 정렬하기3](https://www.acmicpc.net/problem/10989) [#1181 단어정렬](https://www.acmicpc.net/problem/1181)

  


👉 드모르간의 법칙

![Untitled](Sort%20Quiz%20%E1%84%8F%E1%85%B1%E1%86%A8%E1%84%89%E1%85%A9%E1%84%90%E1%85%B3%E1%84%89%E1%85%B5%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%AA%209ea01496d40943a6a793d225baed3098/Untitled.png)
