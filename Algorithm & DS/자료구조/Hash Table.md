---
excerpt: 해시 테이블
tags:
  - Data
  - Structure
Created At: 2023-04-19
---
# Hash Table

[1)](https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o)

**해시 테이블은 연관배열 구조를 이용하여 키(Key)에 결과 값(value)을 저장하는 자료구조이다.**

키Key: 고유한 값이며, 해시함수의 input이다. 다양한 길이의 값이 될 수 있다. 이 상태로 저장되면 다양한 길이의 저장소가 구성되어야 하기 때문에 해시 함수로 값을 바꾸어 저장이 되어야 공간의 효율성을 추구할 수 있다.

해시함수Hash function: 키를 해시값으로 변환하는 과정을 해시 함수라고 한다. 일반적으로 해시 함수는 나머지를 구하는 연산 을 하거나 그 연산을 응용할 때 주로 사용한다.

해시값Value: 해시값을 통해 접근하는 경우 데이터의 추가와 제거가 용이해진다.

키와 해시는 대응 관계까 1:1일 필요는 없다. 중복되는 현상을 **충돌collision**이라고 한다. 

**Node**: 개별 버킷 단위는 **key**, **value**, **next**-뒤쪽 노드를 참조-로 이루어져 있다. 다만, 파이썬의 경우 변수는 객체와 연결된 이름이므로, key와 value도 값이 아니라 객체에 대한 참조를 나타낸다.

연관배열 구조(associative array): 키 1개와 값 1개가 1:1로 연관되어 있는 자료구조이다. 따라서 키를 이용하여 값을 도출할 수 있다.

- 키와 값이 주어졌을 때, 연관배열에 그 두 값을 저장
- 키가 주어졌을 때, 연관되는 값을 얻는 명령
- 키와 새로운 값이 주어졌을 때, 원래 키에 연관된 값을 새로운 값으로 교체하는 명령
- 키가 주어졌을 때, 그 키에 연관된 값을 제거하는 명령

삽입Insert: 시간복잡도 O(1)이지만 최악의 경우 O(n)-해시 충돌로 모든bucket의 value들을 찾아봐야 하는 경우 (해시 함수의 시간복잡도는 고려하지 않는다)

삭제Deletion: 시간복잡도 O(1)이지만 최악의 경우 O(n)-해시 충돌로 모든bucket의 value들을 찾아봐야 하는 경우

Collision을 회피하기 위한 두가지 방법

## **체인법chaining**

해시값이 같은 데이터를 체인 모양의 연결 리스트로 연결하는 방법. 오픈 해시법open hashing이라고도 한다. 배열의 각 버킷(해시테이블)에 저장하는 것은 인덱스를 해시값으로 하는 연결 리스트의 앞쪽 노드를 참조하는 것이다.

**장점**

1) 한정된 저장소를 효율적으로 사용할 수 있다.

2) 해시 함수를 선택하는 중요성이 상대적으로 적다.

3) 상대적으로 적은 메모리를 사용한다. 미리 공간을 잡아놓을 필요가 없다.

**단점**

1) 한 hash에 계속 자료가 쏠리면 검색 효율이 낮아진다.

2) 외부 저장 공간을 사용한다.

3) 외부 저장 공간 작업을 추가로 해야한다.

**시간복잡도**

Insertion: 키 수 = m, 저장소 길이 = n일때 m/n을 alpha(1개의 해시당 m/n개의 키가 들어있음)라고 정의하면, 충돌이 없을경우 O(1)이지만 테일에 저장할 경우O(alpha)의 시간복잡도를 가진다. 해당 해시를 저장할 때 모든 연결리스트를 지나서 tail에 접근해야 하기 때문이다. 최악의 경우O(n)의 시간복잡도를 가진다-한 개의 해시에 모든 자료가 연결된 경우-.

Deletion & Search: 산출된 hash의 연결리스트를 살펴보아야 하므로 모두 O(alpha)의 시간 복잡도를 가진다. 최악의 경우O(n)이다(insertion과 동일 이유).

<aside>
👉 **해시와 해시함수에 대하여**

충돌이 전혀 발생하지 않는다면 해시 함수로 인덱스를 찾는 것 만으로 검색.추가.삭제가 대부분 완료되므로 시간 복잡도는 O(1)이다.

해시 테이블을 충분히 크게 만들면 충돌 발생을 억제할 수 있지만 메모리를 낭비하게 된다-시간, 공간간의 trade-off 발생

해시 테이블 크기보다 해시 값이 작아야 하므로 테이블 크기는 소수가 선호됨.

key가 int인 경우: key를 해시 크기 capacity로 나눈 나머지를 해시값으로 사용한다. 

key가 int가 아닌 경우: 표준 라이브러리 형 변환하여 해시값으로 변환한다-sha256(hashlib모듈에서 제공하며, RSA의 FIPS알고리즘을 기반으로 한다)다음 함수들을 사용한다.→encode() 바이트 문자열 생성, hexdigest() 해시값을 16진수 문자열로 꺼냄, int() 16진수 문자열로 하는 int형으로 변환

</aside>

### **ChainedHash Class** 만들기

![해시 테이블과 chained list로 연결된 키값들의 모습](Hash%20Table%204a261e63d0e74f268f85bbb6b7f99809/Untitled.png)

해시 테이블과 chained list로 연결된 키값들의 모습

→ 2주차_HashTable.py 파일을 확인해 보면 작성된 모습을 확인할 수 있다.

Capacity: 해시 테이블의 크기 / table: 테이블을 저장하는 list형 배열

**search() 함수**

1. 해시 함수를 사용하여 키를 해시값으로 변환
2. 해시값을 인덱스로 하는 버킷에 주목
3. 참조하는 연결리스트를 맨 앞부터 차례로 스캔. 키와 같은값 발견하면 검색에 성공, 원소의 맨 끝까지 스캔해서 발견되지 않으면 검색에 실패

**add() 함수**

1. 해시 함수를 사용하여 키를 해시값으로 변환
2. 해시값을 인덱스로 하는 버킷에 주목
3. 연결 리스트를 선형 검색, 키와 같은 값 발견시 추가 실패, 발견되지 않으면 해시값인 리스트의 맨 앞에 노드를 추가

**remove() 함수**

1. 해시 함수를 사용하여 키를 해시값으로 변환
2. 해시값을 인덱스로 하는 버킷에 주목
3. 버킷이 참조하는 연결 리스트를 맨 앞부터 차례로 선형 검색. 키와 같은 값이 발견되면 그 노드를 리스트에서 삭제. 그렇지 않으면 삭제에 실패

## **오픈 주소법open addressing**

**Open addressing**: 충돌collision이 발생할 경우 재해시를 통해(재해시를 위한 해시 함수는 자유롭게 가능) 오픈 주소법은 빈 버킷이 나올 때까지 재해시를 반복하므로 선형 탐사법linear probing이라고도 한다. 닫힌 해시법closed hashing이라고도 한다.

재해시한 값은 존재하지 않는다고 판단할 수 있으므로 오픈 주소법은 다음과 같이 각 버킷에 다음과 같은 속성을 부여한다 → 데이터가 저장되어 있음(숫자) / 비어있음(-) / 삭제 완료(★)

원소 검색하기: 비어있음의 경우 검색을 더 하지 않지만 삭제 완료인 경우 재해시를 통해 다음 버킷들을 검색해 나간다.

비어있는 해시를 찾는 규칙에는 다음과 같은 종류가 있다.

1) 선형 탐색(Linear Probing): 다음 해시(+1)이나 n개(+n)를 건너뛰어 비어있는 해시에 데이터를 저장한다.

2) 제곱 탐색(Quadratic Probing): 충돌이 일어난 해시의 제곱을 한 해시에 데이터를 저장한다.

3) 이중 해시(Double Hashing): 다른 해시함수를 한 번 더 적용한 해시에 데이터를 저장한다.

장점

1) 다른 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능하다.

2) 다른 저장공간에서의 추가적인 작업이 없다.

단점

1) 해시 함수의 성능에 전체 해시테이블의 성능이 좌우된다.

2) 데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해야 한다.

**시간복잡도**

chaining과 같이 alpha를 정의하면, 버킷 1개당 1개의 값value를 가지기 때문에 이 값은 1보다 작다.

Insertion, Deletion과 Search모두 대상 hash를 찾아가는 과정에 의해 시간복잡도가 결정된다. 비어있지 않은 버킷을 찾아나가는 횟수가 많아질수록 시간복잡도가 증가한다.O(1) ~ O(n)

비어있는 공간을 확보하는 것이 중요하다(저장소가 어느정도 채워졌을 때 저장소의 사이즈를 늘려주는 것).

## Hash Table Data Structure의 단점

순서가 있는 배열에는 어울리지 않는다.

상하관계나 순서가 중요한  데이터의 경우 Hash table은 어울리지 않는다. 순서와 상관없이 Key만을 가지고 hash를 저장하기 때문이다.

공간 효율성이 떨어진다.

데이터가 저장되기 전에 미리 저장공간을 확보해 놓아야 한다. 공간이 부족하거나 아예 채워지지 은 경우가 생길 가능성이 있다.

Hash Function에의 의존성이 높다.

평균 데이터 처리의 시간 복잡도는O(1)이지만, 이는 해시 함수의 연산을 고려하지 않은 결과이다. 해시함수가 복잡하다면 해시테이블의 모든 연산의 시간 효율성은 증가한다.