## 변수
변수의 선언
- 데이터가 저장된 메모리 주소는 컴퓨터가 접근하여 사용한다.
- 변수의 선언은 프로그래머가 사용할 수 있는 논리성(논리적 명칭)을 부여하는 것이다.
- 프로그래머가 원하는 값을 컴퓨터가 사용할 수 있도록 데이터를 변수에 넣는 것을 변수 초기화라고 한다.
## 문자
- 컴퓨터에서 문자는 숫자에 “문자” 형식의 의미를 부여하는 것이다(논리성).
- ASCII나 Unicode 모두 바이너리 값에 특정 문자라는 의미를 부여하는 것: 해당 메모리 주소를 가리키는 변수를 숫자임을 명시해주면 컴파일러는 숫자로 해석함.
- **주의**: char의 초기화는 `' '`와 같이 중간에 유니코드 32를 포함시켜 초기화 시킨다. 아무것도 없이 작은 따옴표만을 사용하면 컴파일 에러가 발생
### Escape Character
`\t`: Insert tab
`\n`: Insert a newline, **Line Feed**
`\'`: Insert `'`
`\"`: Insert `"`
`\\`: Insert `\`
`\r`: **Carriage Return**, 다음 줄 맨 앞으로.
## 숫자
성능의 향상
- 물리적 숫자 데이터는 필요에 따라 논리적으로 필요한 부분을 빠르게 사용하는 데 집중한다.
- 내가 사용하는 부분의 데이터의 범위를 규정하여 논리적으로 가공하여 연산한다.
    - 정수 연산기는 실수에 비해 10~100배 빠름
- 예시
    - 소수점 셋째 자리까지 사용할 경우 1000 배하는 정수 연산을 활용한다.
    - 결과 값은 다시 나누기 1000
### ✨ 실수

- 첫 자리는 부호를 나타낸다.
- 이런 설계는 2의 보수를 통해 덧셈 만으로 연산이 가능하게 해 준다: -128 ~ 127
- 실수 데이터의 경우 8 bit로 7자리가 넘어가면(첫 자리는 부호를 나타내므로) 오차가 발생한다: `==`연산자로 비교해서는 안된다.
```C++
float f1 = 10.3f;
float f2 = 10 + 3 / 10f;

if(f1 == f2) {
// 가수부가 달라질 수 있어 비교해서는 안된다. 
}

if(Math.abs(f1-f2) < 0.1) {
// abs(): 절대값, 두 수의 차이가 내가 원하는 오차 사이인지 판단해야 
}
```
#### 보수
각 자리의 숫자 합이 어느 일정한 수가 되게 하는 수. 현재의 숫자에서 자릿수가 한 단계 올라가게 하기 위한 수이다.
##### r 진법의 보수
- 숫자 N의 (r-1)의 보수: 최댓값  - N
- 숫자 N의 r의 보수: (r-1)의 보수 +1
#### 2 진법에서 1과 2의 보수
이진법 수에 대한 보수를 구해보자.
- 예시: 1010
	1의 보수: 1111 - 1010 = 0101
	2의 보수: 0101 + 0001 = 0110
컴퓨터 체계에서 2의 보수는 2진법에서 음수를 나타내게 된다. 이진수와 그 2의 보수를 더하면 overflow 한 뒤 0이 되어버리기 때문.
참고: [보수란?](https://gdnn.tistory.com/289)
## 자동 형변환
- 큰 데이터 타입 = 작은 데이터 타입으로 할당 가능(자동 형변환)
	예외: char 타입보다 허용 범위가 작은 byte 타입은 char 타입으로 자동 변환될 수 없음
	byte는 변수로 사용할 때 내부적으로 int형으로 바꾸어서 사용하기 때문이다(성능 때문).
- 💕 메모리 → CPU로 데이터를 이동시킬 때(변수값을 읽어서 CPU로) 다양한 데이터를 어떻게 전달하는 것이 효율적일까?
- 4 byte 단위로 전달: 이보다 작은 데이터는 마스킹 해서 빼야하는 과정이 더 필요: 성능 저하
- 자바에서는 이런 과정을 줄이기 위해 4byte 로 내부적으로 변환하여 전달한다.
    - 초기화: 컴파일 시
    - 변수 대입: 런타임 시
```C++
char ch = 'A';
ch = 65;// 컴파일

byte b = 65;

ch = b; // 런타임: 이 경우에 해당한다 <- 💕
```
- 정수 타입 변수가 산술 연산식에서 피연산자로 사용되면 int 타입보다 작은byte, short 타입 변수는int 타입으로 자동 변환되어 연산 수행: 역시 이 것도 앞선 것처럼 성능 이슈 때문임
- 실수 결과를 내는 나누기 연산식을 int 변수에 대입하면 나머지 부분은 사라진다.
### 메모리 주소
숫자를 다루는 메모리의 논리성에 따른 해석의 구별: 서식/프로토콜을 통한 의사소통의 예
- 메모리 주소의 위치는 상(높은 주소)-하(낮은 주소) 일수도, 하-상 일수도 있다: 제조사에 따라 다름.
    - 예시: 55 → 2 진수: 110111, 16 진수: 37(11 / 0111 을 8, 4, 2, 1 바이너리로 합하면 쉽게 구함)
    - Mac
        - 상 - 하 0x0037
    - Intel
        - 하 - 상 0x3700 → 10 진수: 14080
- 실수도 마찬가지
→ 메모리 주소 값을 다루게 되면 하드웨어 플랫폼에 따라 다르게 동작해야 한다.