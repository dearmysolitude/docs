## 문자
- 컴퓨터에서 문자는 숫자에 “문자” 형식의 의미를 부여(논리성)
- ASCII나 Unicode 모두 바이너리 값에 특정 문자라는 의미를 부여하는 것: 해당 메모리 주소를 가리키는 변수를 숫자임을 명시해주면 컴파일러는 숫자로 해석함.
- **주의**: char의 초기화는 `' '`와 같이 중간에 유니코드 32를 포함시켜 초기화 시킨다. 아무것도 없이 작은 따옴표만을 사용하면 컴파일 에러가 발생
### Escape Character
`\t`: Insert tab
`\n`: Insert a newline, **Line Feed**
`\'`: Insert `'`
`\"`: Insert `"`
`\\`: Insert `\`
`\r`: **Carriage Return**, 다음 줄 맨 앞으로.
## 숫자
성능의 향상
- 물리적 숫자 데이터는 필요에 따라 논리적으로 필요한 부분을 빠르게 사용하는 데 집중한다.
- 내가 사용하는 부분의 데이터의 범위를 규정하여 논리적으로 가공하여 연산한다.
    - 정수 연산기는 실수에 비해 10~100배 빠름
- 예시
    - 소수점 셋째 자리까지 사용할 경우 1000 배하는 정수 연산을 활용한다.
    - 결과 값은 다시 나누기 1000
### ✨ 실수
첫 자리는 부호(2의 보수를 통해 덧셈 만으로 연산 가능해짐): -128 ~ 127
**2의 보수에 대해서는 한번 훑어 보자. 자꾸 잊어버리네.**
**char: 65535 → short: -1 ✔ 2의 보수 복습 좀: 원래 수와 더했을 때 0 이 나오면 2의 보수라고 한다. 프로그래밍 언어에서는 첫째 bit를 부호로 사용하므로 가령 0000 0000 0000 1111의 경우 그 보수는 1111 1111 1111 0001이다.**
실수 데이터는 유효숫자가 7 자리 이하이므로 오차가 발생한다: `==` 으로 비교하면 안된다!
**→ float 데이터와 double 데이터의 형 변환**
```C++
float f1 = 10.3f;
float f2 = 10 + 3 / 10f;

if(f1 == f2) {
// 가수부가 달라질 수 있어 비교해서는 안된다. 
}

if(Math.abs(f1-f2) < 0.1) {
// abs(): 절대값, 두 수의 차이가 내가 원하는 오차 사이인지 판단해야 
}
```
## 2의 보수, 1의 보수

## 자바: 자동 형변환
- 큰 데이터 타입 = 작은 데이터 타입으로 할당 가능(자동 형변환)
	예외: char 타입보다 허용 범위가 작은 byte 타입은 char 타입으로 자동 변환될 수 없음
	byte는 변수로 사용할 때 내부적으로 int형으로 바꾸어서 사용하기 때문이다(성능 때문).
- 💕 메모리 → CPU로 데이터를 이동시킬 때(변수값을 읽어서 CPU로) 다양한 데이터를 어떻게 전달하는 것이 효율적일까?
- 4 byte 단위로 전달: 이보다 작은 데이터는 마스킹 해서 빼야하는 과정이 더 필요: 성능 저하
- 자바에서는 이런 과정을 줄이기 위해 4byte 로 내부적으로 변환하여 전달한다.
    - 초기화: 컴파일 시
    - 변수 대입: 런타임 시
```C++
char ch = 'A';
ch = 65;// 컴파일

byte b = 65;

ch = b; // 런타임: 이 경우에 해당한다 <- 💕
```
- 정수 타입 변수가 산술 연산식에서 피연산자로 사용되면 int 타입보다 작은byte, short 타입 변수는int 타입으로 자동 변환되어 연산 수행: 역시 이 것도 앞선 것처럼 성능 이슈 때문임
- 실수 결과를 내는 나누기 연산식을 int 변수에 대입하면 나머지 부분은 사라진다.
### 메모리 주소
숫자를 다루는 메모리의 논리성에 따른 해석의 구별: 서식/프로토콜을 통한 의사소통의 예
- 메모리 주소의 위치는 상(높은 주소)-하(낮은 주소) 일수도, 하-상 일수도 있다: 제조사에 따라 다름.
    - 예시: 55 → 2 진수: 110111, 16 진수: 37(11 / 0111 을 8, 4, 2, 1 바이너리로 합하면 쉽게 구함)
    - Mac
        - 상 - 하 0x0037
    - Intel
        - 하 - 상 0x3700 → 10 진수: 14080
- 실수도 마찬가지
→ 메모리 주소 값을 다루게 되면 하드웨어 플랫폼에 따라 다르게 동작해야 한다.